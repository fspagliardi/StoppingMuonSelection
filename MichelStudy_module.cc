//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "lardataobj/Simulation/SimChannel.h"
#include "larsim/Simulation/LArG4Parameters.h"
#include "larsim/Simulation/LArVoxelData.h"
#include "larsim/Simulation/LArVoxelList.h"
#include "larsim/Simulation/SimListUtils.h"
#include "larsim/MCCheater/BackTrackerService.h"
#include "larsim/MCCheater/ParticleInventoryService.h"
#include "larcore/Geometry/Geometry.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/TrackHitMeta.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "larreco/Calorimetry/CalorimetryAlg.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "larreco/RecoAlg/PMAlg/Utilities.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "larcoreobj/SimpleTypesAndConstants/PhysicalConstants.h"
#include "lardata/Utilities/DatabaseUtil.h"
// my includes
#include "larcorealg/Geometry/TPCGeo.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "dune/Protodune/Analysis/ProtoDUNETrackUtils.h"
#include "dune/Protodune/Analysis/ProtoDUNETruthUtils.h"
#include "dune/Protodune/Analysis/ProtoDUNEPFParticleUtils.h"

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art_root_io/TFileService.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "lardata/ArtDataHelper/MVAReader.h"

#include <fstream>
#include "TTree.h"
#include "TH2.h"
#include "TProfile2D.h"
#include "TMath.h"

#define PI 3.14159265
#define INV_DBL -9999999
#define INV_INT -999

namespace MichelStudystudynsp {

class MichelStudy;

class MichelStudy : public art::EDAnalyzer {
public:
  explicit MichelStudy(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MichelStudy(MichelStudy const &) = delete;
  MichelStudy(MichelStudy &&) = delete;
  MichelStudy & operator = (MichelStudy const &) = delete;
  MichelStudy & operator = (MichelStudy &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions
  void beginJob() override;
  void endJob() override;
  void beginRun(const art::Run& run) override;
  void reconfigure(fhicl::ParameterSet const& p);

  // My functions
  void initActiveVol(double *fActiveBounds);
  void orderRecoStartEnd(TVector3 &start, TVector3 &end, TVector3 &start_dir, TVector3 &end_dir);
  void orderRecoStartEnd(TVector3 &start, TVector3 &end);
  unsigned int TrueParticleFirstPointInAV(double *v, simb::MCParticle const & p);
  double LifeTimeCorr(double ticks, double T0);
  void Reset();
  bool IsTrackNotFittingSpacePoints(TVector3 &posExtremeValidPoint, TVector3 &pos20cmValidPoint, const std::vector<recob::SpacePoint> & spacePoints, const std::string &whichEnd);
  void FillLineCoeff(TVector3 &posLastValidPoint, TVector3 &pos20cmLastValidPoint, double *coeffLineYZ, double *coeffLineXZ);
  TVector3 FindFoot(double *coeffLine, const double &sp_Y, const double &sp_Z);
  bool IsTrackValid(const recob::Track & tr);
  bool IsPointInVolume(double *v, TVector3 const &t);
  bool IsPointInSlice(double *v,TVector3 const &p, double const & thicknessStartVolume);
  bool IsTrackAStoppingMuonCC(art::Event const &evt,int &recoTrackID,double const& trackLength,double const &theta_yz,double const &theta_xz,double const &minHitPeakTime,double const &maxHitPeakTime,TVector3 const &recoStartPoint,TVector3 const &recoEndPoint,const std::vector<recob::PFParticle> & pfparticles);
  bool IsTrackATrueStopper(const int & pdg, TVector3 const &trueStartPoint, TVector3 const &trueEndPoint);
  void CreateTrackPicture(TProfile2D *image, const std::vector<art::Ptr<recob::Hit>> &trackHits, TVector3 const &recoEndPoint);
  bool IsTrackWithMichelHits(const std::vector<art::Ptr<recob::Hit>> &trackHits,TVector3 &recoEndPoint,art::FindManyP<recob::Hit,recob::TrackHitMeta> &fmthm, std::vector<art::Ptr<recob::Track>> &tracklist, size_t &trackIndex); 
  TVector3 GetHitXYZ(art::FindManyP<recob::Hit,recob::TrackHitMeta> &fmthm, const art::Ptr<recob::Hit> &hitp, std::vector<art::Ptr<recob::Track>> &tracklist, size_t &trackIndex);

private:
  // Define variables for TTree
  size_t fEvNumber;
  double fTrackLength = INV_DBL;
  double fTLength = INV_DBL;
  int fRecoTrackID = INV_INT;
  double fT0_reco = INV_DBL;
  double ftheta_xz = INV_DBL;
  double ftheta_yz = INV_DBL;
  bool fIsTrackNotFittingSpacePoints = false;
  Double_t dqdx[3][3000];
  Double_t dedx[3][3000];
  Double_t resrange[3][3000];
  Double_t hitx[3][3000];
  Double_t hity[3][3000];
  Double_t hitz[3][3000];
  Double_t hitPeakTime[3][3000];
  Double_t dqdx_corr[3][3000];
  Double_t corr_factors[3][3000];
  Double_t drift_time[3][3000];
  Double_t track_pitch[3][3000];
  int trackHitNumb[3]; // Number of hits in the track
  double fMinHitPeakTime = INV_DBL;
  double fMaxHitPeakTime = INV_DBL;
  int fTrackIndex;
  double fEndPointZ;

  // TTree variables
  double ftotEnergyIDE, fenergyElectron, fenergyMuon;
  std::vector<double> energyFracElectron, energyFracMuon, distanceFromEnd;
  bool fIsRecoSelectedCathodeCrosser, fIsTrueSelectedCathodeCrosser;
  TProfile2D *fh_imageCollection = nullptr; 

  // Define parameters for cilinder space points
  double cilinderAxis = 50.; // cm
  double cilinderRadius = 5.; // cm
  size_t minNumberSpacePoints = 10.;

  // Strings for track orientation
  const std::string bottom = "bottom";
  const std::string top = "top";
  // Declare arrays to store bounds
  double fActiveBounds[6] = {0.};
  double fActiveBounds_eff[6] = {0.};
  double APABoundaries[2] = {0.};
  double pitchCollection = 0;
  unsigned int wireCollection = 0;
  // Arrays with TPC number info
  const unsigned int tpcIndecesBL[3] = {2,6,10};
  const unsigned int tpcIndecesBR[3] = {1,5,9};

  TTree *fTree;
  // Declare histos 
  TH2D *fh_dQdx_RR;
  TH2D *fh_dQdx_RR_MClifetime;

  // Declare some counters for statistic purposes
  int counter_T0_tagged_tracks = 0;
  int counter_total_number_events = 0;
  int counter_total_number_tracks = 0;

  // Declar fhicl parameters to be read from the configuration file
  std::string   fTrackerTag;       // Module label from track reconstruction
  //std::string   fParticleTag;      // Module label for particle simulation
  std::string   fCalorimetryTag;   // Module label for calorimetry
  std::string   fPFParticleTag;    // Module label for PFParticle
  std::string   fSpacePointTag;    // Module label for SpacePoint
  std::string   fHitTag;           // Module label for Hit
  bool          fStoreOnlyTracksWithoutMichelHits;
  bool          fCreateImages;
  double        fElectronHitEnergyFracThr;

  // Declare handle for geometry
  const geo::GeometryCore *geom = lar::providerFrom<geo::Geometry>();
  // Declare handle for detector properties
  const detinfo::DetectorProperties *detprop = lar::providerFrom<detinfo::DetectorPropertiesService>();
  // Declare handle for particle inventory service
  art::ServiceHandle<cheat::ParticleInventoryService> pi_serv;
  // Declare handle for backtracker
  art::ServiceHandle<cheat::BackTrackerService> bt_serv;

  // Declare analysis utils
  protoana::ProtoDUNETruthUtils        truthUtil;
  protoana::ProtoDUNETrackUtils        trackUtil;
  protoana::ProtoDUNEPFParticleUtils   pfpUtil;

};


MichelStudy::MichelStudy(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)
{
  reconfigure(p);
}

void MichelStudy::beginJob()
{
  art::ServiceHandle<art::TFileService> tfs;
  fh_dQdx_RR = tfs->make<TH2D>("fh_dQdx_RR","fh_dQdx_RR",200,0,200,800,0,800); 
  fh_dQdx_RR_MClifetime = tfs->make<TH2D>("fh_dQdx_RR_MClifetime","fh_dQdx_RR_MClifetime",200,0,200,800,0,800); 
  fTree = tfs->make<TTree>("TrackTree","TrackTree");
  fTree->Branch("totEnergyIDE",&ftotEnergyIDE);
  fTree->Branch("energyElectron",&fenergyElectron);
  fTree->Branch("energyMuon",&fenergyMuon);
  fTree->Branch("endPointZ", &fEndPointZ);
  fTree->Branch("trackIndex", fTrackIndex);
  fTree->Branch("energyFracElectron",&energyFracElectron);
  fTree->Branch("energyFracMuon",&energyFracMuon);
  fTree->Branch("distanceFromEnd",&distanceFromEnd);
  fTree->Branch("isRecoSelectedCathodeCrosser",&fIsRecoSelectedCathodeCrosser);
  fTree->Branch("isTrueSelectedCathodeCrosser",&fIsTrueSelectedCathodeCrosser);
  fTree->Branch("h_imageCollection","TProfile2D",&fh_imageCollection,64000,0);

  initActiveVol(fActiveBounds);

  // Print some detector properties
  std::cout << "**************************  " << std::endl
            << "SamplingRate: " << detprop->SamplingRate() << std::endl
            << "NumberTimeSamples: " << detprop->NumberTimeSamples() << std::endl
            << "Window size: " << detprop->SamplingRate()*detprop->NumberTimeSamples()/1000. << std::endl
            << "ReadOutWindowSize: " << detprop->ReadOutWindowSize() << std::endl
            << "Drift velocity: " << detprop->DriftVelocity()*1e-3 << " cm/ns" << std::endl
            << "Trigger Offset: " << detprop->TriggerOffset() << std::endl
            << "Electric Field: " << detprop->Efield() << std::endl
            << "Temperature: " << detprop->Temperature() << std::endl
            << "Electron Lifetime: " << detprop->ElectronLifetime() << std::endl
            << "Density: " << detprop->Density(detprop->Temperature()) << std::endl
            << "**************************  " << std::endl;
  // Print FHICL parameters
  std::cout << "FHICL paramters:" << std::endl
            << "StoreOnlyTracksWithoutMichelHits: " << fStoreOnlyTracksWithoutMichelHits << std::endl
            << "CreateImages: " << fCreateImages << std::endl
            << "ElectronHitEnergyFracThr: " << fElectronHitEnergyFracThr << std::endl
            << "**************************  " << std::endl;
  
  unsigned int nWiresBL = 0, nWiresBR = 0;
  // Print coordinate of different wire planes in World Coordinate
  for (geo::PlaneID const& pID: geom->IteratePlaneIDs()) {
    geo::PlaneGeo const& planeHandle = geom->Plane(pID);
    //std::cout << "Plane ID: " << pID.Plane << "| Coordinates: x=" << planeHandle.GetCenter().X() << " y=" << planeHandle.GetCenter().Y() << " z=" << planeHandle.GetCenter().Z() << std::endl;
    if (pID.Plane != 2) continue;
    pitchCollection = planeHandle.WirePitch();
    unsigned int tpcid = pID.TPC;
    //std::cout << "TPC ID: " << tpcid << " Numb. of wires for plane 2 in that TPC: " << planeHandle.Nwires();
    bool itsBL = false, itsBR = false;
    for (int it=0;it<3;it++) {
      if (tpcIndecesBL[it] == tpcid)
        itsBL = true;
      else if (tpcIndecesBR[it] == tpcid)
        itsBR = true;
    }
    if (itsBL) 
      nWiresBL += planeHandle.Nwires();     
    if (itsBR)
      nWiresBR += planeHandle.Nwires();
  }

  if (nWiresBR == nWiresBL)
    wireCollection = nWiresBL;
  else
    std::cout << "Two sides don't have same number of wires" << std::endl;
  std::cout << "Pitch: " << pitchCollection << " Wires: " << wireCollection << std::endl;
  // Initialize histogram
  fh_imageCollection = new TProfile2D("fh_imageCollection","fh_imageCollection",wireCollection,0,wireCollection,6000,0,6000);

}

void MichelStudy::endJob()
{
  mf::LogVerbatim("MichelStudy") << "MichelStudy finished job";
  std::cout << "Total number of events: " << counter_total_number_events << std::endl;
  std::cout << "Total number of tracks: " << counter_total_number_tracks << std::endl;
  std::cout << "Number of T0-tagged tracks: " << counter_T0_tagged_tracks << std::endl;
}

void MichelStudy::beginRun(const art::Run&)
{
}

void MichelStudy::analyze(art::Event const & evt)
{
  // increase counter and store event number
  counter_total_number_events++;
  fEvNumber = evt.id().event();
  std::cout << "MichelStudy_module is on event: " << fEvNumber << std::endl;
  mf::LogVerbatim("MichelStudy") << "MichelStudy module on event " << fEvNumber;
  
  // Get hold of all the track
  // trackHandle is art::ValidHandle<std::vector<recob::Track>>
  auto const pfparticleHandle = evt.getValidHandle<std::vector<recob::PFParticle>>(fPFParticleTag);
  auto const & recoParticles = *pfparticleHandle;
  auto const spacePointHandle = evt.getValidHandle<std::vector<recob::SpacePoint>>(fSpacePointTag);
  const std::vector<recob::SpacePoint> spacePoints = *spacePointHandle;
  auto const hitHandle = evt.getValidHandle<std::vector<recob::Hit>>(fHitTag);
  const std::vector<recob::Hit> allHits = *hitHandle;
  
  // Get metadata
  art::Handle<std::vector<recob::Track>> trackListHandle;
  std::vector<art::Ptr<recob::Track>> tracklist;
  if (evt.getByLabel(fTrackerTag,trackListHandle))
    art::fill_ptr_vector(tracklist, trackListHandle);
  art::FindManyP<recob::Hit, recob::TrackHitMeta> fmthm(trackListHandle, evt, fTrackerTag);

  // Get association between track and hits
  art::FindManyP<recob::Hit> fmht(trackListHandle, evt, fTrackerTag);

  // Iterates over the vector of PFParticles
  for (unsigned int p = 0; p < recoParticles.size(); ++p)
  {
    // Reset Calorimetry arrays
    Reset();
    
    // Get the PFParticle
    const recob::PFParticle thisParticle = recoParticles[p];

    // Only consider primary particles
    if (!thisParticle.IsPrimary()) continue;

    // Get and store T0
    std::vector<anab::T0> pfparticleT0s = pfpUtil.GetPFParticleT0(thisParticle,evt,fPFParticleTag);
    if (pfparticleT0s.size() == 0)
      fT0_reco = INV_DBL;
    else { 
      fT0_reco = pfparticleT0s[0].Time();
      counter_T0_tagged_tracks++;
    }
    
    // Get SpacePoints associated to PFParticle
    //const std::vector<const recob::SpacePoint*> spacePoints = pfpUtil.GetPFParticleSpacePoints(thisParticle,evt,fPFParticleTag);

    // Get recob::Track from PFParticle
    const recob::Track *trackP = pfpUtil.GetPFParticleTrack(thisParticle,evt,fPFParticleTag,fTrackerTag);
    if (trackP == nullptr) continue;
    const recob::Track &track = *(trackP);
    counter_total_number_tracks++;
    TVector3 recoEndPoint = track.End<TVector3>();
    TVector3 recoStartPoint(track.LocationAtPoint(track.FirstValidPoint()).X(), track.LocationAtPoint(track.FirstValidPoint()).Y(), track.LocationAtPoint(track.FirstValidPoint()).Z());
    orderRecoStartEnd(recoStartPoint, recoEndPoint);
    fTrackLength = track.Length();
    fRecoTrackID = track.ID();
    // using the ordered start and end points calculate the angles theta_xz and theta_yz
    ftheta_xz = TMath::RadToDeg() * TMath::ATan2(recoStartPoint.X()-recoEndPoint.X(), recoStartPoint.Z()-recoEndPoint.Z());
    ftheta_yz = TMath::RadToDeg() * TMath::ATan2(recoStartPoint.Y()-recoEndPoint.Y(), recoStartPoint.Z()-recoEndPoint.Z());

    // Get Hits associated with PFParticle
    const std::vector<const recob::Hit*> Hits = pfpUtil.GetPFParticleHits(thisParticle,evt,fPFParticleTag);
    // Get track index. Will be needed for association to hit
    size_t trackIndex = INV_INT;
    for (size_t trkIter=0;trkIter<tracklist.size();trkIter++) {
      if (tracklist[trkIter]->ID() == track.ID()) {
        trackIndex = trkIter;
        break;
      }
    }
    // Get hits associated to the track
    const std::vector<art::Ptr<recob::Hit>> trackHits = fmht.at(trackIndex);
    // Fill vector with Hit Peak Times and store minimum
    std::vector<double> HitPeakTimes;
    for (unsigned int hitIndex = 0; hitIndex < Hits.size(); ++hitIndex)   {
      HitPeakTimes.push_back(Hits[hitIndex]->PeakTime());
    }
    fMinHitPeakTime = *(std::min_element(HitPeakTimes.begin(), HitPeakTimes.end()));
    fMaxHitPeakTime = *(std::max_element(HitPeakTimes.begin(), HitPeakTimes.end()));


    const simb::MCParticle *particleP = 0x0;
    int pdg;
    TVector3 trueStartPoint,trueEndPoint;
    if (!evt.isRealData()) {
      particleP = truthUtil.GetMCParticleFromRecoTrack(track,evt,fTrackerTag);
      if (particleP!=0x0) {
        unsigned int fp = TrueParticleFirstPointInAV(fActiveBounds_eff,*particleP);
        pdg = particleP->PdgCode();
        trueEndPoint.SetXYZ(particleP->EndPosition().X(),particleP->EndPosition().Y(),particleP->EndPosition().Z());
        trueStartPoint.SetXYZ(particleP->Vx(fp),particleP->Vy(fp),particleP->Vz(fp));
      }
    }
    
    // Work only with event with matched truth particle and coming from cosmic rays. Unless it's data.
    if ((particleP == 0x0 || pi_serv->TrackIdToMCTruth_P(particleP->TrackId())->Origin() != simb::kCosmicRay) && (!evt.isRealData()))
      continue;

    //
    // Check if some space points are not fitted
    //
    if (IsTrackValid(track) && track.Length()>100. ) {
      // Only for tracks coming from cosmic rays --> Check if there are space points not fitted 
      TVector3 posLastValidPoint, pos20cmLastValidPoint, posFirstValidPoint, pos20cmFirstValidPoint;
      posLastValidPoint = track.LocationAtPoint<TVector3>(track.LastValidPoint());
      posFirstValidPoint = track.LocationAtPoint<TVector3>(track.FirstValidPoint());
      bool found1 = false, found2 = false;

      for (size_t ii = 0; ii <= track.NumberTrajectoryPoints(); ii++)   {
        if (!track.HasValidPoint(ii)) continue;
        pos20cmLastValidPoint = track.LocationAtPoint<TVector3>(ii);
        if (TMath::Abs((pos20cmLastValidPoint-posLastValidPoint).Mag()-20.) < 5) {
          found1 = true;
          break;
        }
      }
      for (size_t ii = 0; ii <= track.NumberTrajectoryPoints(); ii++)   {
        if (!track.HasValidPoint(ii)) continue;
        pos20cmFirstValidPoint = track.LocationAtPoint<TVector3>(ii);
        if (TMath::Abs((pos20cmFirstValidPoint-posFirstValidPoint).Mag()-20.) < 5) {
          found2 = true;
          break;
        }
      }
      //std::cout << found1 << " " << found2 << std::endl;
      if (!found1 || !found2) {
        pos20cmLastValidPoint = posFirstValidPoint;
        pos20cmFirstValidPoint = posLastValidPoint;
      }
      
      if (fT0_reco == INV_DBL)
        fIsTrackNotFittingSpacePoints = (IsTrackNotFittingSpacePoints(posLastValidPoint,pos20cmLastValidPoint,spacePoints,bottom) || IsTrackNotFittingSpacePoints(posFirstValidPoint,pos20cmFirstValidPoint,spacePoints,top));
      else
        fIsTrackNotFittingSpacePoints = IsTrackNotFittingSpacePoints(posLastValidPoint,pos20cmLastValidPoint,spacePoints,bottom);

      if (fIsTrackNotFittingSpacePoints)  {
        //std::cout << "Bad track---> Event: " << fEvNumber << " trackID: " << fRecoTrackID << std::endl;
        //std::cout << "\t\t\t endY: " << recoEndPoint.Y() << " endZ: " << recoEndPoint.Z() << std::endl;
      }
    }
    // -------------- End search for space points not fitted ------------------// 
    
    // Skip if track is not a stopper 
    if (!IsTrackAStoppingMuonCC(evt,fRecoTrackID,fTrackLength,ftheta_yz,ftheta_xz,fMinHitPeakTime,fMaxHitPeakTime,recoStartPoint,recoEndPoint,recoParticles) || fIsTrackNotFittingSpacePoints || fT0_reco == INV_DBL)
      continue; // Go to the next track

    if (fCreateImages && IsTrackWithMichelHits(trackHits,recoEndPoint,fmthm,tracklist,trackIndex))
      CreateTrackPicture(fh_imageCollection,trackHits,recoEndPoint);
    
    if (fStoreOnlyTracksWithoutMichelHits && IsTrackWithMichelHits(trackHits,recoEndPoint,fmthm,tracklist,trackIndex)) 
      continue;
    
    std::cout << "Track identified as a stopper" << std::endl; 
    fIsRecoSelectedCathodeCrosser = true;
    fIsTrueSelectedCathodeCrosser = IsTrackATrueStopper(pdg,trueStartPoint,trueEndPoint);
    
    // Now this should be a stopping muon.
    // Get Calorimetry object from the track
    std::vector<anab::Calorimetry> calos = trackUtil.GetRecoTrackCalorimetry(track,evt,fTrackerTag,fCalorimetryTag);
    if (calos.size() == 0) {
      std::cout << "Calorimetry vector for this track is empyt. Skipping track." << std::endl;
      continue;
    }
    // Store calorimetry information
    std::cout << "Doing the calorimetry" << std::endl;
    for (size_t itcal = 0; itcal < calos.size(); itcal++) {
      if (!(calos[itcal].PlaneID().isValid)) {std::cout << "plane not valid"<< std::endl;continue;}
      int planeNumb = calos[itcal].PlaneID().Plane;
      if (planeNumb<0 || planeNumb>2) {std::cout << "plane number not valid"<< std::endl;continue;}
      size_t const Nhits = calos[itcal].dEdx().size();
      trackHitNumb[planeNumb] = int(Nhits);
      //geo::PlaneID Plane = calos[itcal].PlaneID();
      for (size_t itHit = 0; itHit < Nhits; itHit++)  {
        //std::cout << "TpIndex: " << (calos[itcal].TpIndices())[itHit] << std::endl;
        auto const & TrackPos = (calos[itcal].XYZ())[itHit];
        dqdx[planeNumb][itHit]=(calos[itcal].dQdx())[itHit];
        dedx[planeNumb][itHit]=(calos[itcal].dEdx())[itHit];
        resrange[planeNumb][itHit]=(calos[itcal].ResidualRange())[itHit];
        hitx[planeNumb][itHit]=TrackPos.X();
    	  hity[planeNumb][itHit]=TrackPos.Y();
    	  hitz[planeNumb][itHit]=TrackPos.Z();
        track_pitch[planeNumb][itHit]=(calos[itcal].TrkPitchVec())[itHit];
        // Get Hit Peak Time
        //const size_t & hitIndex = (calos[itcal].TpIndices())[itHit];
        //const auto & thisHit = allHits[hitIndex];
        //hitPeakTime[planeNumb][itHit] = thisHit.PeakTime();
        hitPeakTime[planeNumb][itHit] = INV_DBL; // For now in MCC11
        // Apply Lifetime corrections
        const geo::Point_t HitPoint(TrackPos.X(), TrackPos.Y(), TrackPos.Z());
        geo::TPCID const & tpcid = geom->FindTPCAtPosition(HitPoint);
        if (!tpcid.isValid) {std::cout << "tpc not valid"<< std::endl;continue;}
        int CryoID = geom->FindCryostatAtPosition(HitPoint);
        double Ticks = detprop->ConvertXToTicks(TrackPos.X(), planeNumb, tpcid.TPC, CryoID);
        drift_time[planeNumb][itHit] = (Ticks - detprop->TriggerOffset()) * detprop->SamplingRate()*1e-3;
        corr_factors[planeNumb][itHit] = LifeTimeCorr(Ticks, 0);
        dqdx_corr[planeNumb][itHit] = dqdx[planeNumb][itHit] * corr_factors[planeNumb][itHit];
        // Fill hists
        if ((planeNumb == 2) && (TMath::Abs(track_pitch[planeNumb][itHit]-0.75)<=0.1)) {
          //std::cout << "Filling dQdx vs RR histos," << std::endl;
          fh_dQdx_RR->Fill(resrange[planeNumb][itHit],dqdx[planeNumb][itHit]);  
          fh_dQdx_RR_MClifetime->Fill(resrange[planeNumb][itHit],dqdx_corr[planeNumb][itHit]);  
        }
      }
    }
   
    std::cout << "Event: " << fEvNumber << std::endl;
    std::cout << "TrackIndex: " << trackIndex << std::endl;
    std::cout << "End Point: " << recoEndPoint.X() << " " << recoEndPoint.Y() << " " << recoEndPoint.Z() << std::endl;
    
    double totEnergyDeposited = 0;
    double totEnergyElectron = 0;
    double totEnergyMuon = 0;
    for(const art::Ptr<recob::Hit> & hitp : trackHits) {
      // Get hit 3D position
      TVector3 hitLoc = GetHitXYZ(fmthm, hitp, tracklist, trackIndex);
      
      // Iterates on true energy deposition associated to hit
      for(const sim::TrackIDE& ide : bt_serv->HitToTrackIDEs(*hitp)) {
        if (hitLoc == TVector3(INV_DBL,INV_DBL,INV_DBL))
          distanceFromEnd.push_back(INV_DBL);
        else
          distanceFromEnd.push_back((hitLoc-recoEndPoint).Mag());
        
        totEnergyDeposited += ide.energy;
        if (TMath::Abs(pi_serv->TrackIdToParticle_P(ide.trackID)->PdgCode())==13) {//contribution from muon
          totEnergyMuon += ide.energy;
          energyFracMuon.push_back(ide.energyFrac);
        }
        else 
          energyFracMuon.push_back(INV_DBL);

        if (TMath::Abs(pi_serv->TrackIdToParticle_P(ide.trackID)->PdgCode())==11)  {//contribution from electron
          totEnergyElectron += ide.energy;
          energyFracElectron.push_back(ide.energyFrac);
          if (fStoreOnlyTracksWithoutMichelHits && ide.energyFrac>fElectronHitEnergyFracThr && hitLoc!=TVector3(INV_DBL,INV_DBL,INV_DBL))
            std::cout << "You shouldn't see this line. This line means that despite you asked for track without Michel, there are some." << std::endl;
        }
        else
          energyFracElectron.push_back(INV_DBL);
      }//Iteration on particles for that hit.
    } // iteration on hits

    // Fill TTree Variables and write TTree by selected stopping muon track
    ftotEnergyIDE = totEnergyDeposited;
    fenergyElectron = totEnergyElectron;
    fenergyMuon = totEnergyMuon;
    fTrackIndex = trackIndex;
    fEndPointZ = recoEndPoint.Z();
    fTree->Fill();
    
  
  } // end of loop over PFParticles

} // end of analyzer

//
//
// Implmentation of functions
//
//

TVector3 MichelStudy::GetHitXYZ(art::FindManyP<recob::Hit,recob::TrackHitMeta> &fmthm, const art::Ptr<recob::Hit> &hitp, std::vector<art::Ptr<recob::Track>> &tracklist, size_t &trackIndex) {
 
  TVector3 hitLoc(INV_DBL,INV_DBL,INV_DBL);

  if (!fmthm.isValid()) return hitLoc;

  const std::vector<art::Ptr<recob::Hit>> vhit = fmthm.at(trackIndex);
  const std::vector<const recob::TrackHitMeta*> vmeta = fmthm.data(trackIndex);
  // iterate on meta data
  for (size_t ii=0;ii<vhit.size();++ii) {
    if (vhit[ii].key() != hitp.key())    
      continue;
    if (vmeta[ii]->Index() == std::numeric_limits<int>::max()) {
      continue;
    }
    if (vmeta[ii]->Index()>=tracklist[trackIndex]->NumberTrajectoryPoints()){
      throw cet::exception("Calorimetry_module.cc") << "Requested track trajectory index "<<vmeta[ii]->Index()<<" exceeds the total number of trajectory points "<<tracklist[trackIndex]->NumberTrajectoryPoints()<<" for track index "<<trackIndex<<". Something is wrong";
    }
    if (!tracklist[trackIndex]->HasValidPoint(vmeta[ii]->Index())){
      continue;
    }
    hitLoc = tracklist[trackIndex]->LocationAtPoint<TVector3>(vmeta[ii]->Index());
  } // iteration on metadata

  return hitLoc;
}

void MichelStudy::CreateTrackPicture(TProfile2D* image,const std::vector<art::Ptr<recob::Hit>> &trackHits, TVector3 const &recoEndPoint) {
  image->Reset();
  const geo::Point_t EndPoint(recoEndPoint.X(), recoEndPoint.Y(), recoEndPoint.Z());
  geo::TPCID const & tpcid = geom->FindTPCAtPosition(EndPoint);
  if (!tpcid.isValid) {
    std::cout << "Track End Point is in invalid TPC. Filling the image at (1,1)." << std::endl;
    // Dummy filling
    image->Fill(1,1,1);
    return;
  }
  //unsigned int endPoint_tpcid = tpcid.TPC;

  for (const art::Ptr<recob::Hit> & hitp : trackHits) {
    // Get only hit in the collection plane
    if (!hitp->WireID().isValid) continue;
    if (hitp->WireID().Plane != 2) continue;
    unsigned int hit_tpcid = hitp->WireID().TPC;
    double hitPeakTime = hitp->PeakTime();
    unsigned int wireID = hitp->WireID().Wire;
    double electron_perc = 0;
    for(const sim::TrackIDE& ide : bt_serv->HitToTrackIDEs(*hitp)) {
      if (TMath::Abs(pi_serv->TrackIdToParticle_P(ide.trackID)->PdgCode())==11) {//contribution from electron
        electron_perc = ide.energyFrac;
        //std::cout << "Electron perc: " << electron_perc << std::endl;
      }
    }
    if (hit_tpcid == tpcIndecesBL[0] || hit_tpcid == tpcIndecesBR[0])
      image->Fill(wireID,hitPeakTime,electron_perc);
    else if (hit_tpcid == tpcIndecesBL[1] || hit_tpcid == tpcIndecesBR[1])
      image->Fill((wireCollection/3+wireID),hitPeakTime,electron_perc);
    else if (hit_tpcid == tpcIndecesBL[2] || hit_tpcid == tpcIndecesBR[2])
      image->Fill((2*wireCollection/3+wireID),hitPeakTime,electron_perc);
  }
  return;
}

bool MichelStudy::IsTrackWithMichelHits(const std::vector<art::Ptr<recob::Hit>> &trackHits,TVector3 &recoEndPoint,art::FindManyP<recob::Hit,recob::TrackHitMeta> &fmthm,std::vector<art::Ptr<recob::Track>> &tracklist,size_t &trackIndex) {
  for (const art::Ptr<recob::Hit> &hitp : trackHits) {
    
    for(const sim::TrackIDE& ide : bt_serv->HitToTrackIDEs(*hitp)) {
      if (TMath::Abs(pi_serv->TrackIdToParticle_P(ide.trackID)->PdgCode())==11) {//contribution from electron
        TVector3 hitLoc = GetHitXYZ(fmthm, hitp, tracklist, trackIndex);
        if (hitLoc == TVector3(INV_DBL,INV_DBL,INV_DBL)) continue;
        if (ide.energyFrac>fElectronHitEnergyFracThr && (hitLoc-recoEndPoint).Mag()<15) {
          std::cout << "Found hit with high energy contribution from electrons and within 15 cm from track end point." << std::endl;
          return true;
        }
      }
    }
  }
  return false;
}


bool MichelStudy::IsTrackAStoppingMuonCC(art::Event const &evt,int &recoTrackID,double const& trackLength,double const &theta_yz,double const &theta_xz,double const &minHitPeakTime,double const &maxHitPeakTime,TVector3 const &recoStartPoint,TVector3 const &recoEndPoint,const std::vector<recob::PFParticle> & pfparticles) {
  // Define cuts
  double const length_cutoff = 100;
  double const offsetFiducialBounds = 50;
  double const thicknessStartVolume = 40;
  double const cutMinHitPeakTime = 500;
  double const cutMaxHitPeakTime = 4800;
  double const radiusBrokenTracksSearch = 50;
  double const cutCosAngleBrokenTracks = 0.995;
  double const cutCosAngleAlignment = 0.995;
  double const cutContourAPA = 10;
  double fiducialBounds[6];
  for (int i=0;i<6;i++) {
    if (i%2==0) fiducialBounds[i]=fActiveBounds_eff[i]+offsetFiducialBounds;
    else fiducialBounds[i]=fActiveBounds_eff[i]-offsetFiducialBounds;
  }
  // Apply cuts
  if (trackLength < length_cutoff) return false;
  if (TMath::Abs(theta_yz-90)<10 || TMath::Abs(theta_yz+90)<10 || TMath::Abs(theta_xz-90)<10 || TMath::Abs(theta_xz+90)<10) return false;
  bool goodTrack = ((recoStartPoint.X()*recoEndPoint.X()<0) && IsPointInSlice(fActiveBounds_eff,recoStartPoint,thicknessStartVolume) && IsPointInVolume(fiducialBounds,recoEndPoint)); 
  if (!goodTrack) return false;
  if (minHitPeakTime <= cutMinHitPeakTime) return false;
  if (maxHitPeakTime >= cutMaxHitPeakTime) return false;
  if ((TMath::Abs(recoEndPoint.Z()-APABoundaries[0])<=cutContourAPA) || (TMath::Abs(recoEndPoint.Z()-APABoundaries[1])<=cutContourAPA)) return false;
  // Look for broken tracks
  TVector3 dirFirstTrack = recoEndPoint - recoStartPoint;
  bool isBrokenTrack = false;
  for (size_t p=0;p<pfparticles.size();p++) {
    // Get track
    const recob::Track *newTrack = pfpUtil.GetPFParticleTrack(pfparticles[p],evt,fPFParticleTag,fTrackerTag);
    if (newTrack==nullptr) continue;
    if (newTrack->ID()==recoTrackID) continue;
    size_t fp = newTrack->FirstValidPoint();
    TVector3 recoStartPointSecond(newTrack->LocationAtPoint(fp).X(),newTrack->LocationAtPoint(fp).Y(),newTrack->LocationAtPoint(fp).Z());
    TVector3 recoEndPointSecond = newTrack->End<TVector3>();
    orderRecoStartEnd(recoStartPointSecond,recoEndPointSecond);
    TVector3 dirSecondTrack = recoEndPointSecond-recoStartPointSecond;
    TVector3 dirHigherTrack, dirLowerTrack, endPointHigherTrack, startPointLowerTrack, endPointLowerTrack;
    if (recoStartPoint.Y() > recoStartPointSecond.Y()) {
      dirHigherTrack = dirFirstTrack;
      dirLowerTrack = dirSecondTrack;
      startPointLowerTrack = recoStartPointSecond;
      endPointLowerTrack = recoEndPointSecond;
      endPointHigherTrack = recoEndPoint;
    }
    else
      continue;
    TVector3 middePointLowerTrack = (startPointLowerTrack + endPointLowerTrack) * 0.5;
    TVector3 dirHigherTrack_YZ(0., dirHigherTrack.Y(), dirHigherTrack.Z());
    TVector3 dirJoiningSegment(0., middePointLowerTrack.Y()-endPointHigherTrack.Y(), middePointLowerTrack.Z()-endPointHigherTrack.Z());
    double cosBeta = TMath::Cos(dirHigherTrack_YZ.Angle(dirJoiningSegment));
    double absCosAlpha = TMath::Abs(TMath::Cos(dirFirstTrack.Angle(dirSecondTrack)));

    if ( (absCosAlpha > cutCosAngleBrokenTracks) && (cosBeta >= cutCosAngleAlignment) )    
      isBrokenTrack = true;
                                                          
    double distHigherLower = TMath::Sqrt(TMath::Power(endPointHigherTrack.Y()-startPointLowerTrack.Y(),2) + TMath::Power(endPointHigherTrack.Z()-startPointLowerTrack.Z(),2));
    if (distHigherLower < radiusBrokenTracksSearch) {
      if ( TMath::Abs(TMath::Cos(dirFirstTrack.Angle(dirSecondTrack))) > 0.96)    
        isBrokenTrack = true;
    }
    // Stop searching if found one
    if (isBrokenTrack) break;
  }
  if (isBrokenTrack) return false;
  
  return true;
}

bool MichelStudy::IsTrackATrueStopper(const int & pdg, TVector3 const &trueStartPoint, TVector3 const &trueEndPoint) {
  return (TMath::Abs(pdg)==13 && (trueStartPoint.X()*trueEndPoint.X()<0) && IsPointInVolume(fActiveBounds_eff,trueEndPoint));
}

bool MichelStudy::IsTrackNotFittingSpacePoints(TVector3 &posExtremeValidPoint, TVector3 &pos20cmValidPoint, const std::vector<recob::SpacePoint> & spacePoints, const std::string &whichEnd) {
  //std::cout << "Working with option ---> " << whichEnd << std::endl;
  double coeffLineYZ[2] = {INV_DBL,INV_DBL}, coeffLineXZ[2] = {INV_DBL,INV_DBL};
  FillLineCoeff(posExtremeValidPoint,pos20cmValidPoint,coeffLineYZ,coeffLineXZ);
  //std::cout << coeffLineYZ[0] << " " << coeffLineYZ[1] << " " << coeffLineXZ[0] << " " << coeffLineXZ[1] << std::endl;
  //std::cout << posExtremeValidPoint.Y() << " " << posExtremeValidPoint.Z() << std::endl;
  //std::cout << pos20cmValidPoint.Y() << " " << pos20cmValidPoint.Z() << std::endl;
  size_t spCounter = 0; // count SP

  // Iterates on space points
  for (auto const & sp : spacePoints) {
    
    // Now look at stuff in YZ plane
    TVector3 footYZ = FindFoot(coeffLineYZ,sp.XYZ()[1],sp.XYZ()[2]);
    // Now look at stuff in XZ plane
    TVector3 footXZ = FindFoot(coeffLineXZ,sp.XYZ()[0],sp.XYZ()[2]);

    // Check if the space point is within the designed geometry. NB: The coordinated for the vector foot** 
    // are always such that Y(Z) for every plane
    double distanceFootSpYZ = TMath::Sqrt(TMath::Power(footYZ.Y()-sp.XYZ()[1],2) + TMath::Power(footYZ.Z()-sp.XYZ()[2],2));
    double distanceFootEndYZ = TMath::Sqrt(TMath::Power(footYZ.Y()-posExtremeValidPoint.Y(),2) + TMath::Power(footYZ.Z()-posExtremeValidPoint.Z(),2));
    double distanceFootSpXZ = TMath::Sqrt(TMath::Power(footXZ.Y()-sp.XYZ()[0],2) + TMath::Power(footXZ.Z()-sp.XYZ()[2],2));
    double distanceFootEndXZ = TMath::Sqrt(TMath::Power(footXZ.Y()-posExtremeValidPoint.X(),2) + TMath::Power(footXZ.Z()-posExtremeValidPoint.Z(),2));

    if (whichEnd == "bottom") { // option bottom includes cathode-crossing tracks as well
      // If track is T0 tagged the space points not fitted are not aligned in the XY place because they have 
      // the wrong X while the T0-tagged track has been shifted.   
      if (fT0_reco != INV_DBL) {
        if (distanceFootSpYZ<cilinderRadius && distanceFootEndYZ<cilinderAxis && posExtremeValidPoint.Y()>sp.XYZ()[1]) { 
          spCounter++;
        }
      }
      else if (distanceFootSpYZ<cilinderRadius && distanceFootEndYZ<cilinderAxis && distanceFootSpXZ<cilinderRadius && distanceFootEndXZ<cilinderAxis && posExtremeValidPoint.Y()>sp.XYZ()[1]) { 
        spCounter++;
        //std::cout << "X: " << sp.XYZ()[0] << " Y: " << sp.XYZ()[1] << " Z: " << sp.XYZ()[2] << std::endl;
      }

    }
    else if (whichEnd == "top") {
      if (distanceFootSpYZ<cilinderRadius && distanceFootEndYZ<cilinderAxis && distanceFootSpXZ<cilinderRadius && distanceFootEndXZ<cilinderAxis && posExtremeValidPoint.Y()<sp.XYZ()[1]) { 
        spCounter++;
        //std::cout << "X: " << sp.XYZ()[0] << " Y: " << sp.XYZ()[1] << " Z: " << sp.XYZ()[2] << std::endl;
      }

    }
    else {
      //std::cout << "ERROR: wrong option for function IsTrackNotFittingSpacePoints" << std::endl;
      break;
    }

  } // end loop over space points
  
  //std::cout << "Number of SP in geometry: " << spCounter << std::endl;
  if (spCounter > minNumberSpacePoints)
    return true;
  else
    return false;
}

TVector3 MichelStudy::FindFoot(double *coeffLine, const double &sp_Y, const double &sp_Z)  {
  TVector3 foot(INV_DBL,INV_DBL,INV_DBL);
  double zz = (sp_Y + (sp_Z / coeffLine[1]) - coeffLine[0]) / ( ((coeffLine[1]*coeffLine[1])+1) / coeffLine[1] );
  double yy = (coeffLine[1] * zz) + coeffLine[0];
  foot.SetXYZ(INV_DBL,yy,zz);
  return foot;
}

void MichelStudy::FillLineCoeff(TVector3 &posLastValidPoint, TVector3 &pos20cmLastValidPoint, double *coeffLineYZ, double *coeffLineXZ)  {
  coeffLineYZ[1] = (posLastValidPoint.Y()-pos20cmLastValidPoint.Y()) / (posLastValidPoint.Z()-pos20cmLastValidPoint.Z());   
  coeffLineYZ[0] = pos20cmLastValidPoint.Y() - (pos20cmLastValidPoint.Z()*(coeffLineYZ[1]));
  coeffLineXZ[1] = (posLastValidPoint.X()-pos20cmLastValidPoint.X()) / (posLastValidPoint.Z()-pos20cmLastValidPoint.Z());   
  coeffLineXZ[0] = pos20cmLastValidPoint.X() - (pos20cmLastValidPoint.Z()*(coeffLineXZ[1]));
}

double MichelStudy::LifeTimeCorr(double ticks, double T0) {
  
  double timetick = detprop->SamplingRate()*1e-3; // Sample in microsec
  double presampling = detprop->TriggerOffset();
  //std::cout << "Presampling: " << presampling << std::endl;
  ticks = ticks - presampling;
  double time;
  time = ticks * timetick - T0;
  double tau = detprop->ElectronLifetime();
  double correction = TMath::Exp(time/tau);
  return correction;
}

bool MichelStudy::IsTrackValid(const recob::Track & tr) {
  size_t nValidPointsCounter(0);
  for (size_t j = 0; j < tr.NumberTrajectoryPoints(); j++)   {
    if (tr.HasValidPoint(j))
      nValidPointsCounter++;
  }

  if (nValidPointsCounter > 2)
    return true;
  else
    return false;
}

void MichelStudy::Reset()  {
  energyFracElectron.clear(); 
  energyFracMuon.clear();
  distanceFromEnd.clear();
  fTrackLength = INV_DBL;
  fRecoTrackID = INV_INT;
  fT0_reco = INV_DBL;
  ftheta_xz = INV_DBL;
  ftheta_yz = INV_DBL;
  fMinHitPeakTime = INV_DBL;
  fMaxHitPeakTime = INV_DBL;
  
  for (int j=0; j<3; j++) {
    trackHitNumb[j]=INV_DBL;
    for(int k=0; k<3000; k++){
	    dqdx[j][k]=INV_DBL;
	    dedx[j][k]=INV_DBL;
	    resrange[j][k]=INV_DBL;
	    hitx[j][k]=INV_DBL;
	    hity[j][k]=INV_DBL;
	    hitz[j][k]=INV_DBL;
      hitPeakTime[j][k]=INV_DBL;
      corr_factors[j][k] = INV_DBL;
      dqdx_corr[j][k] = INV_DBL;
      drift_time[j][k] = INV_DBL;
      track_pitch[j][k] = INV_DBL;
	  }
  }
}

unsigned int MichelStudy::TrueParticleFirstPointInAV(double *v, simb::MCParticle const & p)  {

  for (unsigned int t = 0; t < p.NumberTrajectoryPoints(); t++)
  {
    if (p.Vx(t) >= v[0] && p.Vx(t) <= v[1] && p.Vy(t) >= v[2] && p.Vy(t) <= v[3] && p.Vz(t) >= v[4] && p.Vz(t) <= v[5])//
      return t;
  }
  return 999;
}

// //
// //
// Initialize a vector which contains the limits of the Active Volume (taken from MicroBooNE AnalysisTree module)
// //
// //
void MichelStudy::initActiveVol(double *fActiveBounds)  {
  fActiveBounds[0] = fActiveBounds[2] = fActiveBounds[4] = DBL_MAX;
  fActiveBounds[1] = fActiveBounds[3] = fActiveBounds[5] = -DBL_MAX;
  double abs_X_collection = 0;
  auto const* geom = lar::providerFrom<geo::Geometry>();
  for (geo::TPCGeo const& TPC: geom->IterateTPCs())  {
    double origin[3] = {0.};
    double center[3] = {0.};
    //geo::BoxBoundedGeo const& box = TPC.ActiveBoundingBox(); // It says the function does no exist...
    //double center[3] = {box.CenterX(), box.CenterY(), box.CenterZ()};
    TPC.LocalToWorld(origin, center); // had to modify CMakeLists.txt to make this work
    double tpcDim[3] = {TPC.HalfWidth(), TPC.HalfHeight(), 0.5*TPC.Length()};

    //std::cout << "Width: " << 2*TPC.HalfWidth()
    //          << "\nHeight: " << 2*TPC.HalfHeight()
    //          << "\nLength: " << TPC.Length()
    //          << std::endl;

    if( center[0] - tpcDim[0] < fActiveBounds[0]) fActiveBounds[0] = center[0] - tpcDim[0];
    if( center[0] - tpcDim[0] > fActiveBounds[1]) fActiveBounds[1] = center[0] + tpcDim[0];
    if( center[1] - tpcDim[1] < fActiveBounds[2]) fActiveBounds[2] = center[1] - tpcDim[1];
    if( center[1] - tpcDim[1] > fActiveBounds[3]) fActiveBounds[3] = center[1] + tpcDim[1];
    if( center[2] - tpcDim[2] < fActiveBounds[4]) fActiveBounds[4] = center[2] - tpcDim[2];
    if( center[2] - tpcDim[2] > fActiveBounds[5]) fActiveBounds[5] = center[2] + tpcDim[2];

    //check coordinates of collection plane
    geo::PlaneGeo collectionPlane = TPC.LastPlane();
    double planeOrigin[3] = {0.};
    double planeCenter[3] = {0.};
    collectionPlane.LocalToWorld(planeOrigin, planeCenter);
    /*std::cout << "++++++++++++++++++++" << std::setprecision(10) << std::endl
              << "Drift distance: " << TPC.DriftDistance() << std::endl
              << "x Collection Plane: " << planeCenter[0] << std::endl
              << "++++++++++++++++++++" << std::endl;*/
    if (TPC.DriftDistance() > 25)
      abs_X_collection = planeCenter[0];

    //std::cout << "TPCs' drift lengths" << std::endl;
    //std::cout << "TPC ID: " << TPC.ID() << " Drift distance: " << TPC.DriftDistance() << " Drift direction: " << TPC.DriftDirection() << std::endl;

  } // for all TPC

  std::cout << "Active Boundaries:  " << std::setprecision(10)
      << "\n\tx:  " << fActiveBounds[0] << " to " << fActiveBounds[1]
      << "\n\ty:  " << fActiveBounds[2] << " to " << fActiveBounds[3]
      << "\n\tz:  " << fActiveBounds[4] << " to " << fActiveBounds[5]
      << std::endl;
  std::cout << abs_X_collection << std::endl;
  fActiveBounds_eff[0] = -abs(abs_X_collection);
  fActiveBounds_eff[1] = abs(abs_X_collection);
  fActiveBounds_eff[2] = fActiveBounds[2];
  fActiveBounds_eff[3] = fActiveBounds[3];
  fActiveBounds_eff[4] = fActiveBounds[4];
  fActiveBounds_eff[5] = fActiveBounds[5];

  APABoundaries[0] = fActiveBounds_eff[5]/3.;
  APABoundaries[1] = fActiveBounds_eff[5]*2./3.;
}


//
// order reco start and end point
//
void MichelStudy::orderRecoStartEnd(TVector3 &start, TVector3 &end, TVector3 &start_dir, TVector3 &end_dir) {
  double prov_x, prov_y, prov_z;
  if (end.Y() > start.Y()) {
    prov_x = start.X();
    prov_y = start.Y();
    prov_z = start.Z();
    start.SetXYZ(end.X(), end.Y(), end.Z());
    end.SetXYZ(prov_x, prov_y, prov_z);
    for (int k = 0; k<3; k++) {
      TVector3 prov;
      prov = start_dir;
      start_dir = end_dir;
      end_dir = prov;
    }
    return;
  }
  else return;
}

void MichelStudy::orderRecoStartEnd(TVector3 &start, TVector3 &end) {
  double prov_x, prov_y, prov_z;
  if (end.Y() > start.Y()) {
    prov_x = start.X();
    prov_y = start.Y();
    prov_z = start.Z();
    start.SetXYZ(end.X(), end.Y(), end.Z());
    end.SetXYZ(prov_x, prov_y, prov_z);
    return;
  }
  else return;
}

//
// take parameters from .fcl file
//
void MichelStudy::reconfigure(fhicl::ParameterSet const& p)
{
  fTrackerTag = p.get<std::string>("TrackerTag");
  //fParticleTag = p.get<std::string>("ParticleTag");
  fCalorimetryTag = p.get<std::string>("CalorimetryTag");
  fPFParticleTag = p.get<std::string>("PFParticleTag");
  fSpacePointTag = p.get<std::string>("SpacePointTag");
  fHitTag = p.get<std::string>("HitTag");
  fStoreOnlyTracksWithoutMichelHits = p.get<bool>("StoreOnlyTracksWithoutMichelHits");
  fCreateImages = p.get<bool>("CreateImages");
  fElectronHitEnergyFracThr = p.get<double>("ElectronHitEnergyFracThr");
}

bool MichelStudy::IsPointInVolume(double *v, TVector3 const & t)  {
    return (t.X() >= v[0] && t.X() <= v[1] && t.Y() >= v[2] && t.Y() <= v[3] && t.Z() >= v[4] && t.Z() <= v[5]);
}

bool MichelStudy::IsPointInSlice(double *v, TVector3 const & p, double const & thicknessStartVolume)  {
    return ((p.Y()>=(v[3]-thicknessStartVolume) && p.Y()<=v[3]) || (p.X()>=v[0] && p.X()<=(v[0]+thicknessStartVolume)) || (p.X()<=v[1] && p.X()>=(v[1]-thicknessStartVolume)) || (p.Z()>=v[4] && p.Z()<=(v[4]+thicknessStartVolume)) || (p.Z()<=v[5] && p.Z()>=(v[5]-thicknessStartVolume)));

}


} // my_namespace namespace

DEFINE_ART_MODULE(MichelStudystudynsp::MichelStudy)
