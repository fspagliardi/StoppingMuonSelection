///////////////////////////////////////////////////////////////////////
// Class:       CutCheck
// Plugin Type: ******
// File:        CutCheck.h
////////////////////////////////////////////////////////////////////////
#include "dune/Protodune/Analysis/ProtoDUNEPFParticleUtils.h"
#include "art_root_io/TFileService.h"
//#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Core/FileBlock.h"
#include "canvas/Persistency/Common/FindManyP.h"

#include <fstream>
#include <string>
#include "TTree.h"
#include "TH1.h"
#include "TH2.h"
#include "TMath.h"

#include "StoppingMuonSelection/DataTypes.h"
#include "StoppingMuonSelection/GeometryHelper.h"
#include "StoppingMuonSelection/CutCheck/CutCheckHelper.h"

namespace stoppingcosmicmuonselection {

class CutCheck;

class CutCheck : public art::EDAnalyzer {
public:
  explicit CutCheck(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  CutCheck(CutCheck const &) = delete;
  CutCheck(CutCheck &&) = delete;
  CutCheck & operator = (CutCheck const &) = delete;
  CutCheck & operator = (CutCheck &&) = delete;

  // Required functions.
  void analyze(art::Event const &evt) override;

  // Selected optional functions
  void beginJob() override;
  void endJob() override;
  void reconfigure(fhicl::ParameterSet const& p);
  void respondToOpenInputFile(art::FileBlock const &inputFile) override;

private:

  CutCheckHelper           cutCheckHelper; // need configuration
  GeometryHelper           geoHelper;

  // Parameters form FHICL File
  double _trackPitch;
  double _trackPitchTolerance;
  bool _selectAC, _selectCC;
  std::string fPFParticleTag, fTrackerTag;

  // Utils
  protoana::ProtoDUNEPFParticleUtils   pfpUtil;

  // Track Tree stuff
  TTree *fTrackTree;
  // Tree variables
  size_t fEvNumber;
  int    fPdgID = INV_INT;
  double fTrackLength = INV_DBL;
  double fEndX = INV_DBL;
  double fEndY = INV_DBL;
  double fEndZ = INV_DBL;
  double fStartX = INV_DBL;
  double fStartY = INV_DBL;
  double fStartZ = INV_DBL;
  double fRecoTrackID = INV_DBL;
  double fTEndX = INV_DBL;
  double fTEndY = INV_DBL;
  double fTEndZ = INV_DBL;
  double fTStartX = INV_DBL;
  double fTStartY = INV_DBL;
  double fTStartZ = INV_DBL;
  double fTStartT = INV_DBL;
  double fTEndT = INV_DBL;
  double fT0_reco = INV_DBL;
  double fTrackID = INV_DBL;
  double ftheta_xz = INV_DBL;
  double ftheta_yz = INV_DBL;
  double fMinHitPeakTime = INV_DBL;
  double fMaxHitPeakTime = INV_DBL;

  // Objects for TTree
  std::string filename;
  // Histos
  TH2D *h_dQdxVsRR;
  TH2D *h_dQdxVsRR_TP;

  TH1D *h_startX;
  TH1D *h_startX_signal;
  TH1D *h_startY;
  TH1D *h_startY_signal;
  TH1D *h_startZ;
  TH1D *h_startZ_signal;
  TH1D *h_endX;
  TH1D *h_endX_signal;
  TH1D *h_endY;
  TH1D *h_endY_signal;
  TH1D *h_endZ;
  TH1D *h_endZ_signal;
  TH1D *h_minHitPeakTime;
  TH1D *h_minHitPeakTime_signal;
  TH1D *h_maxHitPeakTime;
  TH1D *h_maxHitPeakTime_signal;

};

CutCheck::CutCheck(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)
{
  reconfigure(p);
}

void CutCheck::beginJob()
{
  art::ServiceHandle<art::TFileService> tfs;

  // Histograms
  h_dQdxVsRR = tfs->make<TH2D>("h_dQdxVsRR","h_dQdxVsRR",200,0,200,800,0,800);
  h_dQdxVsRR_TP = tfs->make<TH2D>("h_dQdxVsRR_TP","h_dQdxVsRR_TP",200,0,200,800,0,800);
  h_startX = tfs->make<TH1D>("h_startX","h_startX",400,-400,400);
  h_startX_signal = tfs->make<TH1D>("h_startX_signal","h_startX_signal",400,-400,400);
  h_startY = tfs->make<TH1D>("h_startY","h_startY",400,-100,700);
  h_startY_signal = tfs->make<TH1D>("h_startY_signal","h_startY_signal",400,-100,700);
  h_startZ = tfs->make<TH1D>("h_startZ","h_startZ",450,-100,800);
  h_startZ_signal = tfs->make<TH1D>("h_startZ_signal","h_startZ_signal",450,-100,800);
  h_endX = tfs->make<TH1D>("h_endX","h_endX",400,-400,400);
  h_endX_signal = tfs->make<TH1D>("h_endX_signal","h_endX_signal",400,-400,400);
  h_endY = tfs->make<TH1D>("h_endY","h_endY",400,-400,400);
  h_endY_signal = tfs->make<TH1D>("h_endY_signal","h_endY_signal",400,-400,400);
  h_endZ = tfs->make<TH1D>("h_endZ","h_endZ",400,-400,400);
  h_endZ_signal = tfs->make<TH1D>("h_endZ_signal","h_endZ_signal",400,-400,400);
  h_minHitPeakTime = tfs->make<TH1D>("h_minHitPeakTime","h_minHitPeakTime",3000,0,6000);
  h_minHitPeakTime_signal = tfs->make<TH1D>("h_minHitPeakTime_signal","h_minHitPeakTime_signal",3000,0,6000);
  h_maxHitPeakTime = tfs->make<TH1D>("h_maxHitPeakTime","h_maxHitPeakTime",3000,0,6000);
  h_maxHitPeakTime_signal = tfs->make<TH1D>("h_maxHitPeakTime_signal","h_maxHitPeakTime_signal",3000,0,6000);

}

void CutCheck::endJob()
{
  mf::LogVerbatim("CutCheck") << "CutCheck finished job";
}

void CutCheck::respondToOpenInputFile(art::FileBlock const &inputFile) {
  filename = inputFile.fileName();
  std::cout << "Analyzer on file: " << filename << std::endl;
}

void CutCheck::reconfigure(fhicl::ParameterSet const& p)
{
  fTrackerTag = p.get<std::string>("TrackerTag");
  fPFParticleTag = p.get<std::string>("PFParticleTag");
  _selectAC = p.get<bool>("selectAC", true);
  _selectCC = p.get<bool>("selectCC", true);
  _trackPitch = p.get<double>("trackPitch", 0.75);
  _trackPitchTolerance = p.get<double>("trackPitchTolerance", 0.1);
  cutCheckHelper.reconfigure(p.get<fhicl::ParameterSet>("ConfigSubModules"));
}


} // namespace
